/**
 * Authentication & Authorization Middleware
 * RBAC enforcement with department scoping
 */

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { authService, User } from '../services/authService';

// Extend Express Request to include user
declare global {
  namespace Express {
    interface Request {
      user?: User;
    }
  }
}

// Verify JWT access token
export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Access token required'
      });
    }

    // Verify JWT
    const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-in-production';
    const decoded = jwt.verify(token, JWT_SECRET) as any;

    // Get user data
    const user = authService.getUsers().get(decoded.sub);
    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        error: 'Invalid or inactive user'
      });
    }

    // Attach user to request
    req.user = (authService as any).sanitizeUser(user);

    console.log(`🔐 Authenticated: ${req.user.username} (${req.user.roles.join(', ')})`);
    next();

  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return res.status(401).json({
        success: false,
        error: 'Access token expired',
        code: 'TOKEN_EXPIRED'
      });
    }

    return res.status(403).json({
      success: false,
      error: 'Invalid access token'
    });
  }
};

// Require specific permissions
export const requirePermission = (permission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    if (!authService.hasPermission(req.user, permission)) {
      console.log(`🚫 Permission denied: ${req.user.username} attempted ${permission}`);
      
      // Log unauthorized access attempt
      (authService as any).auditLog(
        'permission_denied',
        req.user.id,
        req.user.id,
        'permission',
        permission,
        'access',
        'failure',
        {
          requestedPermission: permission,
          userPermissions: req.user.permissions,
          endpoint: req.path
        },
        req.ip,
        req.get('User-Agent')
      );

      return res.status(403).json({
        success: false,
        error: 'Insufficient permissions'
      });
    }

    next();
  };
};

// Require specific roles
export const requireRole = (roles: string | string[]) => {
  const requiredRoles = Array.isArray(roles) ? roles : [roles];
  
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const hasRole = requiredRoles.some(role => req.user!.roles.includes(role));
    if (!hasRole) {
      console.log(`🚫 Role access denied: ${req.user.username} attempted ${requiredRoles.join(' or ')}`);
      
      return res.status(403).json({
        success: false,
        error: 'Insufficient role privileges'
      });
    }

    next();
  };
};

// Department scoping middleware
export const requireDepartmentAccess = (req: Request, res: Response, next: NextFunction) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required'
    });
  }

  // Extract department ID from request (params, body, or query)
  const targetDepartmentId = req.params.departmentId || req.body.departmentId || req.query.departmentId;

  if (!targetDepartmentId) {
    // If no specific department requested, user can access their own department data
    return next();
  }

  if (!authService.hasDepartmentAccess(req.user, targetDepartmentId as string)) {
    console.log(`🚫 Department access denied: ${req.user.username} attempted access to department ${targetDepartmentId}`);
    
    // Log unauthorized department access attempt
    (authService as any).auditLog(
      'department_access_denied',
      req.user.id,
      req.user.id,
      'department',
      targetDepartmentId as string,
      'access',
      'failure',
      {
        userDepartment: req.user.departmentId,
        targetDepartment: targetDepartmentId,
        endpoint: req.path
      },
      req.ip,
      req.get('User-Agent')
    );

    return res.status(403).json({
      success: false,
      error: 'Access denied to this department'
    });
  }

  next();
};

// MFA requirement middleware for privileged operations
export const requireMFA = (req: Request, res: Response, next: NextFunction) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required'
    });
  }

  // Check if user has completed MFA recently (step-up authentication)
  const mfaCompleted = req.headers['x-mfa-verified']; // Would be set by MFA verification
  
  if (!mfaCompleted && (req.user.mfaEnabled || req.user.roles.some(role => 
    ['super_admin', 'org_admin', 'macs_head', 'auditor'].includes(role)
  ))) {
    return res.status(403).json({
      success: false,
      error: 'MFA verification required for this operation',
      code: 'MFA_REQUIRED'
    });
  }

  next();
};

// Audit middleware for sensitive operations
export const auditSensitiveOperation = (operation: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next();
    }

    // Log access to sensitive endpoint
    (authService as any).auditLog(
      'sensitive_operation',
      req.user.id,
      req.params.userId || req.user.id,
      'operation',
      operation,
      'access',
      'success',
      {
        endpoint: req.path,
        method: req.method,
        operation
      },
      req.ip,
      req.get('User-Agent')
    );

    next();
  };
};

// Security headers middleware
export const securityHeaders = (req: Request, res: Response, next: NextFunction) => {
  // HSTS (if HTTPS)
  if (req.secure) {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }

  // Content Security Policy
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "connect-src 'self' wss: ws:; " +
    "font-src 'self';"
  );

  // Other security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

  next();
};

export default {
  authenticateToken,
  requirePermission,
  requireRole,
  requireDepartmentAccess,
  requireMFA,
  auditSensitiveOperation,
  securityHeaders
};
