/**
 * Role-Based Access Control (RBAC) Middleware
 * Government-grade authorization with department scoping
 */

import express from 'express';
import jwt from 'jsonwebtoken';
import { authService, User } from '../services/authService';

interface AuthenticatedRequest extends express.Request {
  user?: User;
  session?: any;
}

// JWT verification middleware
export const verifyToken = async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Access token required'
      });
    }

    // Verify JWT
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'dev-secret-change-in-production') as any;

    // In production, verify against database and check session validity
    const user: User = {
      id: decoded.sub,
      username: decoded.username,
      email: decoded.email,
      fullName: decoded.fullName || 'Unknown',
      badgeNumber: decoded.badgeNumber || 'UNKNOWN',
      departmentId: decoded.departmentId,
      clearanceLevel: decoded.clearanceLevel || 'standard',
      isActive: true,
      isVerified: true,
      requiresPasswordChange: false,
      roles: decoded.roles || [],
      permissions: decoded.permissions || [],
      lastLoginAt: decoded.lastLoginAt ? new Date(decoded.lastLoginAt) : undefined,
      mfaEnabled: decoded.mfaEnabled || false,
      webauthnEnabled: decoded.webauthnEnabled || false,
      totpEnabled: decoded.totpEnabled || false
    };

    req.user = user;
    req.session = { sessionId: decoded.sessionId, jti: decoded.jti };

    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return res.status(401).json({
        success: false,
        error: 'Token expired',
        code: 'TOKEN_EXPIRED'
      });
    }

    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({
        success: false,
        error: 'Invalid token',
        code: 'INVALID_TOKEN'
      });
    }

    console.error('Token verification error:', error);
    return res.status(500).json({
      success: false,
      error: 'Token verification failed'
    });
  }
};

// Permission-based authorization
export const requirePermission = (permission: string) => {
  return async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const hasPermission = authService.hasPermission(req.user, permission);
    
    if (!hasPermission) {
      // Log unauthorized access attempt
      console.warn(`🚫 Unauthorized access attempt: ${req.user.username} tried to access ${permission}`);
      
      return res.status(403).json({
        success: false,
        error: 'Insufficient permissions',
        required: permission,
        userPermissions: req.user.permissions
      });
    }

    next();
  };
};

// Role-based authorization
export const requireRole = (roleNames: string | string[]) => {
  const roles = Array.isArray(roleNames) ? roleNames : [roleNames];
  
  return async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const hasRole = roles.some(role => req.user!.roles.includes(role));
    
    if (!hasRole) {
      console.warn(`🚫 Role access denied: ${req.user.username} requires roles: ${roles.join(', ')}`);
      
      return res.status(403).json({
        success: false,
        error: 'Insufficient role privileges',
        required: roles,
        userRoles: req.user.roles
      });
    }

    next();
  };
};

// Department scoping middleware
export const requireDepartmentAccess = (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required'
    });
  }

  const targetDepartmentId = req.params.departmentId || req.body.departmentId || req.query.departmentId;
  
  if (!targetDepartmentId) {
    return res.status(400).json({
      success: false,
      error: 'Department ID required for this operation'
    });
  }

  const hasAccess = authService.hasDepartmentAccess(req.user, targetDepartmentId as string);
  
  if (!hasAccess) {
    console.warn(`🏛️ Department access denied: ${req.user.username} tried to access department ${targetDepartmentId}`);
    
    return res.status(403).json({
      success: false,
      error: 'Access denied to this department',
      userDepartment: req.user.departmentId,
      requestedDepartment: targetDepartmentId
    });
  }

  next();
};

// Clearance level check
export const requireClearanceLevel = (minimumLevel: 'standard' | 'elevated' | 'high' | 'restricted') => {
  const clearanceLevels = {
    'standard': 1,
    'elevated': 2,
    'high': 3,
    'restricted': 4
  };

  return async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const userLevel = clearanceLevels[req.user.clearanceLevel];
    const requiredLevel = clearanceLevels[minimumLevel];

    if (userLevel < requiredLevel) {
      console.warn(`🔒 Clearance denied: ${req.user.username} (${req.user.clearanceLevel}) tried to access ${minimumLevel} resource`);
      
      return res.status(403).json({
        success: false,
        error: 'Insufficient security clearance',
        required: minimumLevel,
        userClearance: req.user.clearanceLevel
      });
    }

    next();
  };
};

// Audit logging middleware
export const auditRequest = (action: string, resourceType: string) => {
  return async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
    const originalSend = res.send;

    res.send = function(data) {
      // Log the request outcome
      const outcome = res.statusCode < 400 ? 'success' : 'failure';
      const resourceId = req.params.id || req.body.id || 'unknown';

      // Note: In production, this would write to immutable audit log
      console.log(`📊 AUDIT: ${req.user?.username || 'anonymous'} ${action} ${resourceType}:${resourceId} - ${outcome}`);

      return originalSend.call(this, data);
    };

    next();
  };
};

// MFA enforcement for privileged operations
export const requireMFA = async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required'
    });
  }

  // Check if user has privileged role that requires MFA
  const privilegedRoles = ['super_admin', 'org_admin', 'macs_head', 'auditor'];
  const hasPrivilegedRole = req.user.roles.some(role => privilegedRoles.includes(role));

  if (hasPrivilegedRole && !req.user.mfaEnabled) {
    return res.status(403).json({
      success: false,
      error: 'MFA required for this operation',
      code: 'MFA_REQUIRED'
    });
  }

  // Check if MFA was recently verified (step-up authentication)
  const mfaTimestamp = req.headers['x-mfa-timestamp'];
  const mfaWindow = 10 * 60 * 1000; // 10 minutes

  if (hasPrivilegedRole && req.user.mfaEnabled) {
    if (!mfaTimestamp || (Date.now() - parseInt(mfaTimestamp as string)) > mfaWindow) {
      return res.status(403).json({
        success: false,
        error: 'Recent MFA verification required',
        code: 'MFA_STEPUP_REQUIRED'
      });
    }
  }

  next();
};

// Security headers middleware
export const securityHeaders = (req: express.Request, res: express.Response, next: express.NextFunction) => {
  // OWASP security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
  
  // HSTS for production
  if (process.env.NODE_ENV === 'production') {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }

  next();
};

// Device fingerprinting for session security
export const deviceFingerprint = (req: express.Request, res: express.Response, next: express.NextFunction) => {
  const userAgent = req.get('User-Agent') || '';
  const acceptLanguage = req.get('Accept-Language') || '';
  const acceptEncoding = req.get('Accept-Encoding') || '';
  
  const fingerprint = require('crypto')
    .createHash('sha256')
    .update(userAgent + acceptLanguage + acceptEncoding)
    .digest('hex');

  (req as any).deviceFingerprint = fingerprint;
  next();
};

export type { AuthenticatedRequest };
