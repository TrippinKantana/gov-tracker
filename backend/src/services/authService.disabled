/**
 * Government-Grade Authentication Service
 * Implements NIST SP 800-63B and OWASP ASVS Level 2+ standards
 */

import argon2 from 'argon2';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import speakeasy from 'speakeasy';
import qrcode from 'qrcode';
import { generateRegistrationOptions, verifyRegistrationResponse, generateAuthenticationOptions, verifyAuthenticationResponse } from '@simplewebauthn/server';
import type { AuthenticatorDevice, VerifiedRegistrationResponse, VerifiedAuthenticationResponse } from '@simplewebauthn/server';

// NIST SP 800-63B compliant Argon2id parameters
const ARGON2_CONFIG = {
  type: argon2.argon2id,
  timeCost: 3,        // NIST minimum
  memoryCost: 65536,  // 64 MiB
  parallelism: 2,     // NIST recommended
  hashLength: 32,     // 256-bit hash
  saltLength: 32      // 256-bit salt
};

const JWT_CONFIG = {
  accessTokenExpiry: '15m',   // Short-lived access tokens
  refreshTokenExpiry: '7d',   // Refresh token rotation
  issuer: 'gov-asset-tracker',
  audience: 'macs-platform'
};

interface User {
  id: string;
  username: string;
  email: string;
  fullName: string;
  badgeNumber: string;
  departmentId?: string;
  clearanceLevel: 'standard' | 'elevated' | 'high' | 'restricted';
  isActive: boolean;
  isVerified: boolean;
  requiresPasswordChange: boolean;
  roles: string[];
  permissions: string[];
  lastLoginAt?: Date;
  mfaEnabled: boolean;
  webauthnEnabled: boolean;
  totpEnabled: boolean;
}

interface AuthSession {
  userId: string;
  sessionId: string;
  deviceFingerprint: string;
  ipAddress: string;
  userAgent: string;
  expiresAt: Date;
  refreshTokenHash: string;
}

interface LoginAttempt {
  identifier: string;
  attempts: number;
  lastAttempt: Date;
  blockedUntil?: Date;
}

class AuthService {
  private readonly JWT_SECRET: string;
  private readonly WEBAUTHN_RP_ID: string;
  private readonly WEBAUTHN_RP_NAME: string;
  private readonly WEBAUTHN_ORIGIN: string;

  // In-memory storage for demo (replace with database in production)
  private users: Map<string, any> = new Map();
  private sessions: Map<string, AuthSession> = new Map();
  private rateLimits: Map<string, LoginAttempt> = new Map();
  private auditEvents: any[] = [];

  constructor() {
    this.JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-in-production';
    this.WEBAUTHN_RP_ID = process.env.WEBAUTHN_RP_ID || 'localhost';
    this.WEBAUTHN_RP_NAME = process.env.WEBAUTHN_RP_NAME || 'Government Asset Tracker';
    this.WEBAUTHN_ORIGIN = process.env.WEBAUTHN_ORIGIN || 'http://localhost:3000';
    
    this.initializeDefaultUsers();
  }

  private initializeDefaultUsers() {
    // Create default super admin user
    this.createDefaultUser({
      id: 'user-super-admin',
      username: 'admin',
      email: 'admin@gov.lr',
      fullName: 'System Administrator',
      badgeNumber: 'GSA-ADMIN',
      password: 'TempPassword123!', // Must be changed on first login
      roles: ['super_admin'],
      departmentId: undefined,
      clearanceLevel: 'restricted'
    });

    // Create MAC Head user
    this.createDefaultUser({
      id: 'user-macs-head-health',
      username: 'health.admin',
      email: 'admin@health.gov.lr',
      fullName: 'Dr. Sarah Johnson',
      badgeNumber: 'GSA-001',
      password: 'TempPassword123!',
      roles: ['macs_head'],
      departmentId: 'dept-health',
      clearanceLevel: 'high'
    });
  }

  private async createDefaultUser(userData: any) {
    const passwordHash = await this.hashPassword(userData.password);
    const user = {
      ...userData,
      passwordHash: passwordHash.hash,
      passwordSalt: passwordHash.salt,
      argon2Config: passwordHash.config,
      isActive: true,
      isVerified: true,
      requiresPasswordChange: true,
      mfaEnabled: false,
      webauthnEnabled: false,
      totpEnabled: false,
      createdAt: new Date(),
      lastLoginAt: null
    };
    
    delete user.password; // Never store plaintext passwords
    this.users.set(user.id, user);
    
    await this.auditLog('user_created', 'system', user.id, 'user', user.id, 'create', 'success', {
      username: user.username,
      roles: user.roles
    });
  }

  // Password hashing with Argon2id (NIST compliant)
  async hashPassword(password: string): Promise<{ hash: string; salt: Buffer; config: any }> {
    try {
      const salt = crypto.randomBytes(ARGON2_CONFIG.saltLength);
      
      const hash = await argon2.hash(password, {
        ...ARGON2_CONFIG,
        salt
      });

      return {
        hash,
        salt,
        config: ARGON2_CONFIG
      };
    } catch (error) {
      throw new Error('Password hashing failed');
    }
  }

  // Verify password against Argon2id hash
  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    try {
      return await argon2.verify(hashedPassword, password);
    } catch (error) {
      return false;
    }
  }

  // Password policy enforcement (NIST compliant)
  validatePassword(password: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Minimum length (NIST recommends 8, we enforce 12 for government)
    if (password.length < 12) {
      errors.push('Password must be at least 12 characters long');
    }

    // Maximum length (prevent DoS)
    if (password.length > 128) {
      errors.push('Password must be less than 128 characters');
    }

    // Check against common passwords (simplified - use hibp API in production)
    const commonPasswords = ['password', 'password123', 'admin', 'government', 'liberia'];
    if (commonPasswords.includes(password.toLowerCase())) {
      errors.push('Password is too common and not allowed');
    }

    // Character diversity check
    const hasLower = /[a-z]/.test(password);
    const hasUpper = /[A-Z]/.test(password);
    const hasNumber = /[0-9]/.test(password);
    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    const charTypeCount = [hasLower, hasUpper, hasNumber, hasSpecial].filter(Boolean).length;
    if (charTypeCount < 3) {
      errors.push('Password must contain at least 3 different character types (lowercase, uppercase, numbers, special characters)');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // Rate limiting for authentication attempts
  async checkRateLimit(identifier: string, action: string, maxAttempts: number = 5, windowMinutes: number = 15): Promise<boolean> {
    const key = `${identifier}:${action}`;
    const now = new Date();
    const windowStart = new Date(now.getTime() - (windowMinutes * 60 * 1000));

    let attempt = this.rateLimits.get(key);
    
    if (!attempt || attempt.lastAttempt < windowStart) {
      // Reset window
      attempt = {
        identifier: key,
        attempts: 1,
        lastAttempt: now
      };
    } else {
      attempt.attempts++;
      attempt.lastAttempt = now;
    }

    if (attempt.attempts >= maxAttempts) {
      attempt.blockedUntil = new Date(now.getTime() + (windowMinutes * 60 * 1000));
    }

    this.rateLimits.set(key, attempt);

    if (attempt.blockedUntil && now < attempt.blockedUntil) {
      await this.auditLog('rate_limit_exceeded', null, null, 'auth', action, 'rate_limit', 'failure', {
        identifier,
        attempts: attempt.attempts,
        blockedUntil: attempt.blockedUntil
      });
      return false;
    }

    return true;
  }

  // User authentication
  async authenticate(username: string, password: string, ipAddress: string, userAgent: string): Promise<{ success: boolean; user?: User; error?: string; requiresMfa?: boolean }> {
    try {
      // Rate limiting
      const rateLimitOk = await this.checkRateLimit(username, 'login', 5, 15);
      if (!rateLimitOk) {
        return { success: false, error: 'Too many failed attempts. Please try again later.' };
      }

      // Find user
      const user = Array.from(this.users.values()).find(u => 
        u.username === username || u.email === username
      );

      if (!user) {
        await this.auditLog('login_failed', null, null, 'auth', 'login', 'authenticate', 'failure', {
          username,
          reason: 'user_not_found',
          ipAddress,
          userAgent
        });
        return { success: false, error: 'Invalid credentials' };
      }

      // Check if account is active
      if (!user.isActive) {
        await this.auditLog('login_failed', null, user.id, 'auth', 'login', 'authenticate', 'failure', {
          username,
          reason: 'account_inactive',
          ipAddress,
          userAgent
        });
        return { success: false, error: 'Account is inactive' };
      }

      // Check if account is locked
      if (user.accountLockedUntil && new Date() < user.accountLockedUntil) {
        await this.auditLog('login_failed', null, user.id, 'auth', 'login', 'authenticate', 'failure', {
          username,
          reason: 'account_locked',
          ipAddress,
          userAgent
        });
        return { success: false, error: 'Account is temporarily locked' };
      }

      // Verify password
      const passwordValid = await this.verifyPassword(password, user.passwordHash);
      if (!passwordValid) {
        // Increment failed attempts
        user.failedLoginAttempts = (user.failedLoginAttempts || 0) + 1;
        
        // Lock account after 5 failed attempts
        if (user.failedLoginAttempts >= 5) {
          user.accountLockedUntil = new Date(Date.now() + (30 * 60 * 1000)); // 30 minutes
        }

        await this.auditLog('login_failed', null, user.id, 'auth', 'login', 'authenticate', 'failure', {
          username,
          reason: 'invalid_password',
          failedAttempts: user.failedLoginAttempts,
          ipAddress,
          userAgent
        });
        return { success: false, error: 'Invalid credentials' };
      }

      // Reset failed attempts on successful password verification
      user.failedLoginAttempts = 0;
      user.accountLockedUntil = null;

      // Check if MFA is required
      if (user.mfaEnabled || this.isPrivilegedRole(user.roles)) {
        return { 
          success: true, 
          requiresMfa: true, 
          user: this.sanitizeUser(user) 
        };
      }

      // Complete login
      const authResult = await this.completeLogin(user, ipAddress, userAgent);
      return authResult;

    } catch (error) {
      console.error('Authentication error:', error);
      return { success: false, error: 'Authentication service error' };
    }
  }

  private async completeLogin(user: any, ipAddress: string, userAgent: string): Promise<{ success: boolean; user: User; tokens: { accessToken: string; refreshToken: string } }> {
    // Update last login
    user.lastLoginAt = new Date();
    user.lastLoginIp = ipAddress;
    user.lastLoginUserAgent = userAgent;

    // Generate tokens
    const tokens = await this.generateTokens(user);

    // Create session
    const session: AuthSession = {
      userId: user.id,
      sessionId: tokens.sessionId,
      deviceFingerprint: this.generateDeviceFingerprint(userAgent),
      ipAddress,
      userAgent,
      expiresAt: new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)), // 7 days
      refreshTokenHash: await this.hashRefreshToken(tokens.refreshToken)
    };

    this.sessions.set(session.sessionId, session);

    await this.auditLog('login_success', user.id, user.id, 'auth', 'login', 'authenticate', 'success', {
      username: user.username,
      ipAddress,
      userAgent,
      sessionId: session.sessionId
    });

    return {
      success: true,
      user: this.sanitizeUser(user),
      tokens: {
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken
      }
    };
  }

  // Generate JWT tokens
  private async generateTokens(user: any): Promise<{ accessToken: string; refreshToken: string; sessionId: string }> {
    const sessionId = crypto.randomUUID();
    const jti = crypto.randomUUID(); // JWT ID for token revocation

    const accessTokenPayload = {
      sub: user.id,
      username: user.username,
      email: user.email,
      roles: user.roles,
      permissions: user.permissions,
      departmentId: user.departmentId,
      clearanceLevel: user.clearanceLevel,
      sessionId,
      jti
    };

    const accessToken = jwt.sign(accessTokenPayload, this.JWT_SECRET, {
      expiresIn: JWT_CONFIG.accessTokenExpiry,
      issuer: JWT_CONFIG.issuer,
      audience: JWT_CONFIG.audience
    });

    const refreshToken = crypto.randomBytes(32).toString('hex');

    return { accessToken, refreshToken, sessionId };
  }

  // WebAuthn/FIDO2 registration
  async generateWebAuthnRegistrationOptions(userId: string): Promise<any> {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }

    const options = await generateRegistrationOptions({
      rpName: this.WEBAUTHN_RP_NAME,
      rpID: this.WEBAUTHN_RP_ID,
      userID: Buffer.from(user.id),
      userName: user.username,
      userDisplayName: user.fullName,
      attestationType: 'direct', // For government security requirements
      authenticatorSelection: {
        authenticatorAttachment: 'cross-platform', // Prefer security keys
        userVerification: 'required',
        residentKey: 'preferred' // Support passwordless
      },
      excludeCredentials: user.webauthnCredentials?.map((cred: any) => ({
        id: Buffer.from(cred.credentialId, 'base64'),
        type: 'public-key',
        transports: cred.transports
      })) || []
    });

    // Store challenge temporarily (use Redis in production)
    user.currentChallenge = options.challenge;

    return options;
  }

  async verifyWebAuthnRegistration(userId: string, credential: any): Promise<{ verified: boolean; credentialId?: string }> {
    const user = this.users.get(userId);
    if (!user || !user.currentChallenge) {
      throw new Error('Invalid registration state');
    }

    const verification = await verifyRegistrationResponse({
      response: credential,
      expectedChallenge: user.currentChallenge,
      expectedOrigin: this.WEBAUTHN_ORIGIN,
      expectedRPID: this.WEBAUTHN_RP_ID
    });

    if (verification.verified && verification.registrationInfo) {
      const { credentialPublicKey, credentialID, counter, aaguid } = verification.registrationInfo;

      // Store credential
      if (!user.webauthnCredentials) {
        user.webauthnCredentials = [];
      }

      const newCredential = {
        credentialId: Buffer.from(credentialID).toString('base64'),
        publicKey: Buffer.from(credentialPublicKey).toString('base64'),
        counter,
        aaguid: Buffer.from(aaguid).toString('base64'),
        createdAt: new Date(),
        isActive: true,
        deviceName: 'Security Key', // Could be enhanced with user input
        transports: credential.response.transports || []
      };

      user.webauthnCredentials.push(newCredential);
      user.webauthnEnabled = true;

      // Clear challenge
      delete user.currentChallenge;

      await this.auditLog('webauthn_registered', userId, userId, 'mfa', 'webauthn', 'register', 'success', {
        credentialId: newCredential.credentialId,
        aaguid: newCredential.aaguid
      });

      return { verified: true, credentialId: newCredential.credentialId };
    }

    return { verified: false };
  }

  // TOTP enrollment
  async enrollTOTP(userId: string): Promise<{ secret: string; qrCode: string; backupCodes: string[] }> {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }

    const secret = speakeasy.generateSecret({
      name: `${user.fullName} (${user.badgeNumber})`,
      issuer: 'Liberia Government - Asset Tracker',
      length: 32 // 256-bit secret
    });

    // Generate QR code
    const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url!);

    // Generate backup codes
    const backupCodes = Array.from({ length: 10 }, () => 
      crypto.randomBytes(4).toString('hex').toUpperCase()
    );

    // Store encrypted (in production, use proper encryption)
    user.totpSecret = secret.base32;
    user.totpBackupCodes = backupCodes;
    user.totpEnabled = true;

    await this.auditLog('totp_enrolled', userId, userId, 'mfa', 'totp', 'enroll', 'success', {
      backupCodesGenerated: backupCodes.length
    });

    return {
      secret: secret.base32,
      qrCode: qrCodeUrl,
      backupCodes
    };
  }

  // Verify TOTP token
  async verifyTOTP(userId: string, token: string): Promise<boolean> {
    const user = this.users.get(userId);
    if (!user || !user.totpSecret) {
      return false;
    }

    const verified = speakeasy.totp.verify({
      secret: user.totpSecret,
      encoding: 'base32',
      token: token,
      window: 1 // Allow 1 step tolerance
    });

    await this.auditLog('totp_verified', userId, userId, 'mfa', 'totp', 'verify', 
      verified ? 'success' : 'failure', { token: token.substring(0, 2) + '****' });

    return verified;
  }

  // Role and permission checks
  hasPermission(user: User, permission: string): boolean {
    // Super admin has all permissions
    if (user.roles.includes('super_admin')) {
      return true;
    }

    // Check explicit permissions
    return user.permissions.some(p => 
      p === permission || 
      p === '*' || 
      p === permission.split(':')[0] + ':*'
    );
  }

  hasDepartmentAccess(user: User, targetDepartmentId: string): boolean {
    // Super admin and org admin have cross-department access
    if (user.roles.includes('super_admin') || user.roles.includes('org_admin')) {
      return true;
    }

    // Auditor has read-only cross-department access
    if (user.roles.includes('auditor')) {
      return true;
    }

    // Others only access their own department
    return user.departmentId === targetDepartmentId;
  }

  private isPrivilegedRole(roles: string[]): boolean {
    const privilegedRoles = ['super_admin', 'org_admin', 'macs_head', 'auditor'];
    return roles.some(role => privilegedRoles.includes(role));
  }

  // Utility functions
  private sanitizeUser(user: any): User {
    return {
      id: user.id,
      username: user.username,
      email: user.email,
      fullName: user.fullName,
      badgeNumber: user.badgeNumber,
      departmentId: user.departmentId,
      clearanceLevel: user.clearanceLevel,
      isActive: user.isActive,
      isVerified: user.isVerified,
      requiresPasswordChange: user.requiresPasswordChange,
      roles: user.roles || [],
      permissions: user.permissions || [],
      lastLoginAt: user.lastLoginAt,
      mfaEnabled: user.mfaEnabled || false,
      webauthnEnabled: user.webauthnEnabled || false,
      totpEnabled: user.totpEnabled || false
    };
  }

  private async hashRefreshToken(token: string): Promise<string> {
    return crypto.createHash('sha256').update(token).digest('hex');
  }

  private generateDeviceFingerprint(userAgent: string): string {
    return crypto.createHash('sha256').update(userAgent).digest('hex');
  }

  // Audit logging (immutable)
  private async auditLog(
    eventType: string,
    actorId: string | null,
    targetUserId: string | null,
    resourceType: string,
    resourceId: string,
    action: string,
    outcome: 'success' | 'failure' | 'partial',
    metadata: any = {},
    ipAddress?: string,
    userAgent?: string
  ): Promise<void> {
    const auditEvent = {
      id: crypto.randomUUID(),
      eventType,
      actorId,
      targetUserId,
      resourceType,
      resourceId,
      action,
      outcome,
      ipAddress,
      userAgent,
      metadata,
      timestamp: new Date().toISOString(),
      riskScore: this.calculateRiskScore(eventType, outcome, metadata)
    };

    this.auditEvents.push(auditEvent);
    console.log('🔒 AUDIT LOG:', auditEvent);

    // In production, write to immutable log storage
  }

  private calculateRiskScore(eventType: string, outcome: string, metadata: any): number {
    let score = 0;

    if (outcome === 'failure') score += 20;
    if (eventType.includes('admin') || eventType.includes('privileged')) score += 30;
    if (metadata.failedAttempts > 3) score += 40;
    if (eventType === 'rate_limit_exceeded') score += 60;

    return Math.min(score, 100);
  }

  // Public getters for testing
  getUsers(): Map<string, any> {
    return this.users;
  }

  getAuditEvents(): any[] {
    return this.auditEvents;
  }
}

export const authService = new AuthService();
export type { User, AuthSession };
