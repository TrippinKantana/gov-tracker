/**
 * Comprehensive Report Generator
 * Generates filtered reports across all asset categories
 */

const PDFDocument = require('pdfkit');

class ReportGenerator {
  constructor({ pool }) {
    this.pool = pool; // Database connection
  }

  /**
   * Generate comprehensive report based on filters
   */
  async generateReport(filters) {
    const {
      macId,
      facilityId,
      reportType,
      reportPeriod,
      customStartDate,
      customEndDate,
      reportMode,
      includeInactive,
      macName,
      facilityName,
      dateRange,
      generatedBy
    } = filters;

    console.log('ðŸ“Š Generating report:', { reportType, reportPeriod, macName, facilityName });

    // Create PDF document
    const doc = new PDFDocument({ size: 'A4', margin: 50 });
    
    // Add header
    this.addReportHeader(doc, {
      title: `${this.getReportTypeTitle(reportType)} Report`,
      subtitle: `${macName}${facilityName ? ` - ${facilityName}` : ''}`,
      period: dateRange.label,
      generatedBy,
      generatedAt: new Date().toLocaleString()
    });

    // Generate content based on report type
    switch (reportType) {
      case 'fleet':
        await this.generateFleetReport(doc, filters);
        break;
      case 'assets':
        await this.generateAssetsReport(doc, filters);
        break;
      case 'facilities':
        await this.generateFacilitiesReport(doc, filters);
        break;
      case 'stock':
        await this.generateStockReport(doc, filters);
        break;
      case 'all':
        await this.generateComprehensiveReport(doc, filters);
        break;
      default:
        throw new Error('Invalid report type');
    }

    // Finalize document
    doc.end();
    return doc;
  }

  /**
   * Add report header with government branding
   */
  addReportHeader(doc, info) {
    // Government Header
    doc.fontSize(20)
       .text('Republic of Liberia', 50, 50, { align: 'center' })
       .fontSize(16)
       .text('General Services Agency', 50, 75, { align: 'center' })
       .fontSize(14)
       .text('Asset Tracking & Management System', 50, 95, { align: 'center' });

    // Add horizontal line
    doc.moveTo(50, 120)
       .lineTo(550, 120)
       .stroke();

    // Report Title
    doc.fontSize(18)
       .text(info.title, 50, 140, { align: 'center' })
       .fontSize(12)
       .text(info.subtitle, 50, 165, { align: 'center' });

    // Report Details
    const startY = 200;
    doc.fontSize(10)
       .text(`Report Period: ${info.period}`, 50, startY)
       .text(`Generated By: ${info.generatedBy}`, 50, startY + 15)
       .text(`Generated On: ${info.generatedAt}`, 50, startY + 30)
       .text(`Report ID: RPT-${Date.now()}`, 50, startY + 45);

    // Add another line
    doc.moveTo(50, startY + 70)
       .lineTo(550, startY + 70)
       .stroke();

    return startY + 90; // Return Y position for content
  }

  /**
   * Generate Fleet Report
   */
  async generateFleetReport(doc, filters) {
    let currentY = 290;
    
    doc.fontSize(14)
       .text('FLEET INVENTORY REPORT', 50, currentY);
    
    currentY += 30;

    // Get real fleet data from API
    const fleetData = await this.fetchFleetData(filters);
    
    if (fleetData.length === 0) {
      doc.fontSize(12)
         .text('No fleet data available for the selected criteria.', 50, currentY);
      return;
    }

    // Table headers
    const headers = ['Plate #', 'Vehicle', 'GSA Code', 'Status', 'Mileage', 'Operator'];
    const columnWidths = [80, 120, 100, 60, 60, 120];
    let startX = 50;

    // Draw headers
    doc.fontSize(10);
    headers.forEach((header, index) => {
      doc.text(header, startX, currentY, { width: columnWidths[index], align: 'center' });
      startX += columnWidths[index];
    });

    currentY += 20;
    
    // Draw header line
    doc.moveTo(50, currentY)
       .lineTo(530, currentY)
       .stroke();

    currentY += 10;

    // Draw fleet data
    fleetData.forEach(vehicle => {
      startX = 50;
      const vehicleData = [
        vehicle.plateNumber,
        `${vehicle.year} ${vehicle.make} ${vehicle.model}`,
        vehicle.gsa_code,
        vehicle.status,
        `${vehicle.mileage} km`,
        vehicle.currentOperator
      ];

      vehicleData.forEach((data, index) => {
        doc.text(data, startX, currentY, { width: columnWidths[index], align: 'center' });
        startX += columnWidths[index];
      });

      currentY += 20;
    });

    // Summary
    currentY += 20;
    doc.fontSize(12)
       .text(`Total Vehicles: ${fleetData.length}`, 50, currentY)
       .text(`Active Vehicles: ${fleetData.filter(v => v.status === 'Active').length}`, 50, currentY + 15)
       .text(`Total Mileage: ${fleetData.reduce((sum, v) => sum + v.mileage, 0).toLocaleString()} km`, 50, currentY + 30);
  }

  /**
   * Generate Assets Report
   */
  async generateAssetsReport(doc, filters) {
    let currentY = 290;
    
    doc.fontSize(14)
       .text('ASSETS INVENTORY REPORT', 50, currentY);
    
    currentY += 30;

    // Get real assets data from API
    const assetsData = await this.fetchAssetsData(filters);
    
    if (assetsData.length === 0) {
      doc.fontSize(12)
         .text('No assets data available for the selected criteria.', 50, currentY);
      return;
    }

    // Equipment summary
    const equipmentCount = assetsData.filter(a => a.category !== 'furniture').length;
    const furnitureCount = assetsData.filter(a => a.category === 'furniture').length;
    
    doc.fontSize(12)
       .text(`Equipment Items: ${equipmentCount}`, 50, currentY)
       .text(`Furniture Items: ${furnitureCount}`, 50, currentY + 15)
       .text(`Total Assets: ${assetsData.length}`, 50, currentY + 30);

    currentY += 60;

    // Assets by category
    const categories = [...new Set(assetsData.map(a => a.category || 'equipment'))];
    categories.forEach(category => {
      const categoryItems = assetsData.filter(a => (a.category || 'equipment') === category);
      doc.text(`${category.toUpperCase()}: ${categoryItems.length} items`, 50, currentY);
      currentY += 15;
    });
  }

  /**
   * Generate Facilities Report
   */
  async generateFacilitiesReport(doc, filters) {
    let currentY = 290;
    
    doc.fontSize(14)
       .text('FACILITIES REPORT', 50, currentY);
    
    currentY += 30;

    // Get real facilities data from API
    const facilitiesData = await this.fetchFacilitiesData(filters);
    
    if (facilitiesData.length === 0) {
      doc.fontSize(12)
         .text('No facilities data available for the selected criteria.', 50, currentY);
      return;
    }

    // Facilities summary
    const operationalCount = facilitiesData.filter(f => f.status === 'operational').length;
    const maintenanceCount = facilitiesData.filter(f => f.status === 'maintenance').length;
    
    doc.fontSize(12)
       .text(`Total Facilities: ${facilitiesData.length}`, 50, currentY)
       .text(`Operational: ${operationalCount}`, 50, currentY + 15)
       .text(`Under Maintenance: ${maintenanceCount}`, 50, currentY + 30);

    currentY += 60;

    // Facilities by type
    const types = [...new Set(facilitiesData.map(f => f.type))];
    types.forEach(type => {
      const typeCount = facilitiesData.filter(f => f.type === type).length;
      doc.text(`${type.replace('_', ' ').toUpperCase()}: ${typeCount}`, 50, currentY);
      currentY += 15;
    });
  }

  /**
   * Generate Stock Inventory Report
   */
  async generateStockReport(doc, filters) {
    let currentY = 290;
    
    doc.fontSize(14)
       .text('STOCK INVENTORY REPORT', 50, currentY);
    
    currentY += 30;

    // Get real stock data from API
    const stockData = await this.fetchStockData(filters);
    
    if (stockData.length === 0) {
      doc.fontSize(12)
         .text('No stock data available for the selected criteria.', 50, currentY);
      return;
    }

    // Table headers
    const headers = ['Item Name', 'SKU', 'Category', 'Quantity', 'Unit', 'Location'];
    const columnWidths = [120, 80, 80, 60, 60, 120];
    let startX = 50;

    // Draw headers
    doc.fontSize(10);
    headers.forEach((header, index) => {
      doc.text(header, startX, currentY, { width: columnWidths[index], align: 'center' });
      startX += columnWidths[index];
    });

    currentY += 20;
    
    // Draw header line
    doc.moveTo(50, currentY)
       .lineTo(530, currentY)
       .stroke();

    currentY += 10;

    // Draw stock data
    stockData.forEach(item => {
      startX = 50;
      const itemData = [
        item.name || 'N/A',
        item.sku || item.id,
        item.category || 'General',
        (item.quantity || 0).toString(),
        item.unit || 'pcs',
        item.location || filters.macName || 'N/A'
      ];

      itemData.forEach((data, index) => {
        doc.text(data, startX, currentY, { width: columnWidths[index], align: 'center' });
        startX += columnWidths[index];
      });

      currentY += 20;
      
      // Check for page break
      if (currentY > 700) {
        doc.addPage();
        currentY = 50;
      }
    });

    // Summary
    currentY += 20;
    const totalQuantity = stockData.reduce((sum, item) => sum + (item.quantity || 0), 0);
    const lowStockItems = stockData.filter(item => (item.quantity || 0) < (item.minimumLevel || 10));
    
    doc.fontSize(12)
       .text(`Total Items: ${stockData.length}`, 50, currentY)
       .text(`Total Quantity: ${totalQuantity}`, 50, currentY + 15)
       .text(`Low Stock Items: ${lowStockItems.length}`, 50, currentY + 30);
  }

  /**
   * Generate Comprehensive Report (All Categories)
   */
  async generateComprehensiveReport(doc, filters) {
    await this.generateFleetReport(doc, filters);
    doc.addPage();
    await this.generateAssetsReport(doc, filters);
    doc.addPage();
    await this.generateFacilitiesReport(doc, filters);
    doc.addPage();
    await this.generateStockReport(doc, filters);
  }

  /**
   * Get report type title
   */
  getReportTypeTitle(type) {
    switch (type) {
      case 'fleet': return 'FLEET';
      case 'assets': return 'ASSETS';
      case 'facilities': return 'FACILITIES';
      case 'stock': return 'STOCK INVENTORY';
      case 'all': return 'COMPREHENSIVE';
      default: return 'GOVERNMENT';
    }
  }

  /**
   * Fetch real fleet data from API
   */
  async fetchFleetData(filters) {
    try {
      const fetch = require('node-fetch');
      const response = await fetch('http://localhost:5000/api/vehicles');
      const result = await response.json();
      
      if (result.success && result.vehicles) {
        let vehicles = result.vehicles;
        
        // Filter by MAC if specified
        if (filters.macName) {
          vehicles = vehicles.filter(v => v.department === filters.macName);
        }
        
        // Filter by facility if specified
        if (filters.facilityName) {
          vehicles = vehicles.filter(v => v.facilityName === filters.facilityName);
        }
        
        return vehicles;
      }
      return [];
    } catch (error) {
      console.error('Error fetching fleet data:', error);
      return [];
    }
  }

  /**
   * Fetch real assets data from API  
   */
  async fetchAssetsData(filters) {
    try {
      const fetch = require('node-fetch');
      const response = await fetch('http://localhost:5000/api/equipment');
      const result = await response.json();
      
      if (result.success && result.equipment) {
        let equipment = result.equipment;
        
        // Filter by MAC if specified
        if (filters.macName) {
          equipment = equipment.filter(e => e.department === filters.macName);
        }
        
        return equipment;
      }
      return [];
    } catch (error) {
      console.error('Error fetching assets data:', error);
      return [];
    }
  }

  /**
   * Fetch real facilities data from API
   */
  async fetchFacilitiesData(filters) {
    try {
      const fetch = require('node-fetch');
      const response = await fetch('http://localhost:5000/api/facilities');
      const result = await response.json();
      
      if (result.success && result.facilities) {
        let facilities = result.facilities;
        
        // Filter by MAC if specified
        if (filters.macName) {
          facilities = facilities.filter(f => f.department === filters.macName);
        }
        
        return facilities;
      }
      return [];
    } catch (error) {
      console.error('Error fetching facilities data:', error);
      return [];
    }
  }

  /**
   * Fetch real stock data from API
   */
  async fetchStockData(filters) {
    try {
      const fetch = require('node-fetch');
      const response = await fetch('http://localhost:5000/api/stock/inventory');
      const result = await response.json();
      
      if (result.success && result.stock) {
        let stock = result.stock;
        
        // Filter by MAC/department if specified
        if (filters.macName) {
          stock = stock.filter(s => s.department === filters.macName || s.location === filters.macName);
        }
        
        return stock;
      }
      return [];
    } catch (error) {
      console.error('Error fetching stock data:', error);
      return [];
    }
  }
}

module.exports = ReportGenerator;
